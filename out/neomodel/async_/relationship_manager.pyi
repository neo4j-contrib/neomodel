from _typeshed import Incomplete
from neomodel import AsyncStructuredNode as AsyncStructuredNode
from neomodel.async_.database import adb as adb
from neomodel.async_.match import AsyncBaseSet as AsyncBaseSet, AsyncNodeSet as AsyncNodeSet, AsyncTraversal as AsyncTraversal
from neomodel.async_.relationship import AsyncStructuredRel as AsyncStructuredRel
from neomodel.exceptions import NotConnected as NotConnected, RelationshipClassRedefined as RelationshipClassRedefined
from neomodel.util import RelationshipDirection as RelationshipDirection, enumerate_traceback as enumerate_traceback, get_graph_entity_properties as get_graph_entity_properties
from typing import Any, AsyncIterator, Callable

def check_source(fn: Callable) -> Callable: ...
def is_direct_subclass(obj: Any, classinfo: Any) -> bool: ...

class AsyncRelationshipManager:
    source: Any
    source_class: Any
    name: str
    definition: dict
    description: str
    def __init__(self, source: Any, key: str, definition: dict) -> None: ...
    def __await__(self) -> Any: ...
    async def check_cardinality(self, node: AsyncStructuredNode) -> None: ...
    @check_source
    async def connect(self, node: AsyncStructuredNode, properties: dict[str, Any] | None = None) -> AsyncStructuredRel | None: ...
    @check_source
    async def replace(self, node: AsyncStructuredNode, properties: dict[str, Any] | None = None) -> None: ...
    @check_source
    async def relationship(self, node: AsyncStructuredNode) -> AsyncStructuredRel | None: ...
    @check_source
    async def all_relationships(self, node: AsyncStructuredNode) -> list[AsyncStructuredRel]: ...
    @check_source
    async def reconnect(self, old_node: AsyncStructuredNode, new_node: AsyncStructuredNode) -> None: ...
    @check_source
    async def disconnect(self, node: AsyncStructuredNode) -> None: ...
    @check_source
    async def disconnect_all(self) -> None: ...
    async def get(self, **kwargs: Any) -> AsyncNodeSet: ...
    async def get_or_none(self, **kwargs: dict) -> AsyncNodeSet: ...
    def filter(self, *args: Any, **kwargs: dict) -> AsyncBaseSet: ...
    def order_by(self, *props: Any) -> AsyncBaseSet: ...
    def exclude(self, *args: Any, **kwargs: dict) -> AsyncBaseSet: ...
    async def is_connected(self, node: AsyncStructuredNode) -> bool: ...
    async def single(self) -> AsyncStructuredNode | None: ...
    def match(self, **kwargs: dict) -> AsyncNodeSet: ...
    async def all(self) -> list: ...
    async def __aiter__(self) -> AsyncIterator: ...
    async def get_len(self) -> int: ...
    async def check_bool(self) -> bool: ...
    async def check_nonzero(self) -> bool: ...
    async def check_contains(self, obj: Any) -> bool: ...
    async def get_item(self, key: int | slice) -> Any: ...

class AsyncRelationshipDefinition:
    module_name: Incomplete
    module_file: Incomplete
    manager: Incomplete
    definition: Incomplete
    def __init__(self, relation_type: str, cls_name: str, direction: int, manager: type[AsyncRelationshipManager] = ..., model: type[AsyncStructuredRel] | None = None) -> None: ...
    def lookup_node_class(self) -> None: ...
    def build_manager(self, source: AsyncStructuredNode, name: str) -> AsyncRelationshipManager: ...

class AsyncZeroOrMore(AsyncRelationshipManager):
    description: str

class AsyncRelationshipTo(AsyncRelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[AsyncRelationshipManager] = ..., model: type[AsyncStructuredRel] | None = None) -> None: ...

class AsyncRelationshipFrom(AsyncRelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[AsyncRelationshipManager] = ..., model: type[AsyncStructuredRel] | None = None) -> None: ...

class AsyncRelationship(AsyncRelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[AsyncRelationshipManager] = ..., model: type[AsyncStructuredRel] | None = None) -> None: ...
