from dataclasses import dataclass
from re import Pattern
from neomodel.async_ import relationship_manager as relationship_manager
from neomodel.async_.database import adb as adb
from neomodel.async_.node import AsyncStructuredNode as AsyncStructuredNode
from neomodel.async_.relationship import AsyncStructuredRel as AsyncStructuredRel
from neomodel.exceptions import MultipleNodesReturned as MultipleNodesReturned
from neomodel.match_q import Q as Q, QBase as QBase
from neomodel.properties import AliasProperty as AliasProperty, ArrayProperty as ArrayProperty, Property as Property
from neomodel.semantic_filters import FulltextFilter as FulltextFilter, VectorFilter as VectorFilter
from neomodel.typing import Subquery as Subquery, Transformation as Transformation
from neomodel.util import RelationshipDirection as RelationshipDirection
from typing import Any, AsyncIterator, Generic, TypeVar

T = TypeVar('T', bound=AsyncStructuredNode)

CYPHER_ACTIONS_WITH_SIDE_EFFECT_EXPR: Pattern
OPERATOR_TABLE: dict[str, str]
path_split_regex: Pattern

def install_traversals(cls, node_set: AsyncNodeSet) -> None: ...
def process_filter_args(cls, kwargs: dict[str, Any]) -> dict: ...
def process_has_args(cls, kwargs: dict[str, Any]) -> tuple[dict, dict]: ...

class QueryAST:
    match: list[str]
    optional_match: list[str]
    where: list[str]
    with_clause: str | None
    return_clause: str | None
    order_by: list[str] | None
    skip: int | None
    limit: int | None
    result_class: type | None
    lookup: str | None
    additional_return: list[str] | None
    is_count: bool | None
    vector_index_query: VectorFilter | None
    fulltext_index_query: FulltextFilter | None
    optional_where: list[str] | None
    subgraph: dict
    mixed_filters: bool
    def __init__(self, match: list[str] | None = None, optional_match: list[str] | None = None, where: list[str] | None = None, optional_where: list[str] | None = None, with_clause: str | None = None, return_clause: str | None = None, order_by: list[str] | None = None, skip: int | None = None, limit: int | None = None, result_class: type | None = None, lookup: str | None = None, additional_return: list[str] | None = None, is_count: bool | None = False, vector_index_query: VectorFilter | None = None, fulltext_index_query: FulltextFilter | None = None) -> None: ...

class AsyncQueryBuilder:
    node_set: AsyncBaseSet
    def __init__(self, node_set: AsyncBaseSet, subquery_namespace: str | None = None) -> None: ...
    async def build_ast(self) -> AsyncQueryBuilder: ...
    async def build_source(self, source: AsyncTraversal | AsyncNodeSet | AsyncStructuredNode | Any) -> str: ...
    def create_relation_identifier(self) -> str: ...
    def create_node_identifier(self, prefix: str, path: str) -> str: ...
    def build_order_by(self, ident: str, source: AsyncNodeSet) -> None: ...
    def build_vector_query(self) -> None: ...
    def build_fulltext_query(self) -> None: ...
    async def build_traversal(self, traversal: AsyncTraversal) -> str: ...
    def build_traversal_from_path(self, relation: Path, source_class: Any) -> tuple[str, Any]: ...
    async def build_node(self, node: AsyncStructuredNode) -> str: ...
    def build_label(self, ident: str, cls: type[AsyncStructuredNode]) -> str: ...
    def build_additional_match(self, ident: str, node_set: AsyncNodeSet) -> None: ...
    def build_where_stmt(self, ident: str, filters: list, source_class: type[AsyncStructuredNode], q_filters: QBase | Any | None = None) -> None: ...
    def lookup_query_variable(self, path: str, return_relation: bool = False) -> tuple[str, Any, bool] | None: ...
    def build_query(self) -> str: ...

class AsyncBaseSet(Generic[T]):
    query_cls = AsyncQueryBuilder
    source_class: type[T]
    async def all(self, lazy: bool = False) -> list[T]: ...
    async def __aiter__(self) -> AsyncIterator[T]: ...
    async def get_len(self) -> int: ...
    async def check_bool(self) -> bool: ...
    async def check_nonzero(self) -> bool: ...
    async def check_contains(self, obj: T | Any) -> bool: ...
    limit: int | None
    skip: int | None
    async def get_item(self, key: int | slice) -> AsyncBaseSet[T] | None: ...

@dataclass
class Optional:
    relation: str

@dataclass
class Path:
    value: str
    optional: bool = ...
    include_nodes_in_return: bool = ...
    include_rels_in_return: bool = ...
    relation_filtering: bool = ...
    alias: str | None = ...

@dataclass
class RelationNameResolver:
    relation: str
    def resolve(self, qbuilder: AsyncQueryBuilder) -> str: ...

@dataclass
class NodeNameResolver:
    node: str
    def resolve(self, qbuilder: AsyncQueryBuilder) -> str: ...

@dataclass
class BaseFunction:
    input_name: str | BaseFunction | NodeNameResolver | RelationNameResolver
    def __post_init__(self) -> None: ...
    def get_internal_name(self) -> str: ...
    def resolve_internal_name(self, qbuilder: AsyncQueryBuilder) -> str: ...
    def render(self, qbuilder: AsyncQueryBuilder) -> str: ...

@dataclass
class AggregatingFunction(BaseFunction): ...

@dataclass
class Collect(AggregatingFunction):
    distinct: bool = ...
    def render(self, qbuilder: AsyncQueryBuilder) -> str: ...

@dataclass
class ScalarFunction(BaseFunction):
    @property
    def function_name(self) -> str: ...
    def render(self, qbuilder: AsyncQueryBuilder) -> str: ...

@dataclass
class Last(ScalarFunction):
    @property
    def function_name(self) -> str: ...

@dataclass
class Size(ScalarFunction):
    @property
    def function_name(self) -> str: ...

@dataclass
class RawCypher:
    statement: str
    def __post_init__(self) -> None: ...
    def render(self, context: dict) -> str: ...

class AsyncNodeSet(AsyncBaseSet[T]):
    source: Any
    source_class: type[T]
    filters: list
    q_filters: Q
    order_by_elements: list
    must_match: dict
    dont_match: dict
    relations_to_fetch: list[Path]
    vector_query: VectorFilter | None
    fulltext_query: FulltextFilter | None
    def __init__(self, source: Any) -> None: ...
    def __await__(self) -> Any: ...
    async def get(self, lazy: bool = False, **kwargs: Any) -> T: ...
    async def get_or_none(self, **kwargs: Any) -> T | None: ...
    async def first(self, **kwargs: Any) -> T: ...
    async def first_or_none(self, **kwargs: Any) -> T | None: ...
    def filter(self, *args: Any, **kwargs: Any) -> AsyncNodeSet[T]: ...
    def exclude(self, *args: Any, **kwargs: Any) -> AsyncNodeSet[T]: ...
    def has(self, **kwargs: Any) -> AsyncNodeSet[T]: ...
    def order_by(self, *props: Any) -> AsyncNodeSet[T]: ...
    def unique_variables(self, *paths: str) -> AsyncNodeSet[T]: ...
    def traverse(self, *paths: tuple[str, ...], **aliased_paths: dict) -> AsyncNodeSet[T]: ...
    def annotate(self, *vars: tuple, **aliased_vars: tuple) -> AsyncNodeSet[T]: ...
    async def resolve_subgraph(self) -> list: ...
    async def subquery(self, nodeset: AsyncNodeSet, return_set: list[str], initial_context: list[str] | None = None) -> AsyncNodeSet[T]: ...
    def intermediate_transform(self, vars: dict[str, Transformation], distinct: bool = False, ordering: list | None = None) -> AsyncNodeSet[T]: ...

class AsyncTraversal(AsyncBaseSet[T]):
    definition: dict
    source: Any
    source_class: Any
    target_class: type[T]
    name: str
    filters: list
    def __await__(self) -> Any: ...
    def __init__(self, source: Any, name: str, definition: dict) -> None: ...
    def match(self, **kwargs: Any) -> AsyncTraversal[T]: ...
