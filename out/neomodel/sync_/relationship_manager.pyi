from _typeshed import Incomplete
from neomodel import StructuredNode as StructuredNode
from neomodel.exceptions import NotConnected as NotConnected, RelationshipClassRedefined as RelationshipClassRedefined
from neomodel.sync_.database import db as db
from neomodel.sync_.match import BaseSet as BaseSet, NodeSet as NodeSet, Traversal as Traversal
from neomodel.sync_.relationship import StructuredRel as StructuredRel
from neomodel.util import RelationshipDirection as RelationshipDirection, enumerate_traceback as enumerate_traceback, get_graph_entity_properties as get_graph_entity_properties
from typing import Any, Callable, Generic, Iterator, TypeVar, overload

T = TypeVar('T', bound=StructuredNode)

def check_source(fn: Callable) -> Callable: ...
def is_direct_subclass(obj: Any, classinfo: Any) -> bool: ...

class RelationshipManager(Generic[T]):
    source: Any
    source_class: Any
    name: str
    definition: dict
    description: str
    def __init__(self, source: Any, key: str, definition: dict) -> None: ...
    def __await__(self) -> Any: ...
    def check_cardinality(self, node: T) -> None: ...
    @check_source
    def connect(self, node: T, properties: dict[str, Any] | None = None) -> StructuredRel | None: ...
    @check_source
    def replace(self, node: T, properties: dict[str, Any] | None = None) -> None: ...
    @check_source
    def relationship(self, node: T) -> StructuredRel | None: ...
    @check_source
    def all_relationships(self, node: T) -> list[StructuredRel]: ...
    @check_source
    def reconnect(self, old_node: T, new_node: T) -> None: ...
    @check_source
    def disconnect(self, node: T) -> None: ...
    @check_source
    def disconnect_all(self) -> None: ...
    def get(self, **kwargs: Any) -> T: ...
    def get_or_none(self, **kwargs: Any) -> T | None: ...
    def filter(self, *args: Any, **kwargs: Any) -> NodeSet[T]: ...
    def order_by(self, *props: Any) -> NodeSet[T]: ...
    def exclude(self, *args: Any, **kwargs: Any) -> NodeSet[T]: ...
    def is_connected(self, node: T) -> bool: ...
    def single(self) -> T | None: ...
    def match(self, **kwargs: Any) -> NodeSet[T]: ...
    def all(self) -> list[T]: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __contains__(self, obj: Any) -> bool: ...
    def __getitem__(self, key: int | slice) -> T: ...

class RelationshipDefinition(Generic[T]):
    module_name: Incomplete
    module_file: Incomplete
    manager: Incomplete
    definition: Incomplete
    def __init__(self, relation_type: str, cls_name: str, direction: int, manager: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...
    def lookup_node_class(self) -> None: ...
    def build_manager(self, source: StructuredNode, name: str) -> RelationshipManager[T]: ...
    @overload
    def __get__(self, obj: None, owner: type | None = None) -> RelationshipDefinition[T]: ...
    @overload
    def __get__(self, obj: Any, owner: type | None = None) -> RelationshipManager[T]: ...

class ZeroOrMore(RelationshipManager[T]):
    description: str

class RelationshipTo(RelationshipDefinition[T]):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...

class RelationshipFrom(RelationshipDefinition[T]):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...

class Relationship(RelationshipDefinition[T]):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...
