from _typeshed import Incomplete
from neomodel import StructuredNode as StructuredNode
from neomodel.exceptions import NotConnected as NotConnected, RelationshipClassRedefined as RelationshipClassRedefined
from neomodel.sync_.database import db as db
from neomodel.sync_.match import BaseSet as BaseSet, NodeSet as NodeSet, Traversal as Traversal
from neomodel.sync_.relationship import StructuredRel as StructuredRel
from neomodel.util import RelationshipDirection as RelationshipDirection, enumerate_traceback as enumerate_traceback, get_graph_entity_properties as get_graph_entity_properties
from typing import Any, Callable, Iterator

def check_source(fn: Callable) -> Callable: ...
def is_direct_subclass(obj: Any, classinfo: Any) -> bool: ...

class RelationshipManager:
    source: Any
    source_class: Any
    name: str
    definition: dict
    description: str
    def __init__(self, source: Any, key: str, definition: dict) -> None: ...
    def __await__(self) -> Any: ...
    def check_cardinality(self, node: StructuredNode) -> None: ...
    @check_source
    def connect(self, node: StructuredNode, properties: dict[str, Any] | None = None) -> StructuredRel | None: ...
    @check_source
    def replace(self, node: StructuredNode, properties: dict[str, Any] | None = None) -> None: ...
    @check_source
    def relationship(self, node: StructuredNode) -> StructuredRel | None: ...
    @check_source
    def all_relationships(self, node: StructuredNode) -> list[StructuredRel]: ...
    @check_source
    def reconnect(self, old_node: StructuredNode, new_node: StructuredNode) -> None: ...
    @check_source
    def disconnect(self, node: StructuredNode) -> None: ...
    @check_source
    def disconnect_all(self) -> None: ...
    def get(self, **kwargs: Any) -> NodeSet: ...
    def get_or_none(self, **kwargs: dict) -> NodeSet: ...
    def filter(self, *args: Any, **kwargs: dict) -> BaseSet: ...
    def order_by(self, *props: Any) -> BaseSet: ...
    def exclude(self, *args: Any, **kwargs: dict) -> BaseSet: ...
    def is_connected(self, node: StructuredNode) -> bool: ...
    def single(self) -> StructuredNode | None: ...
    def match(self, **kwargs: dict) -> NodeSet: ...
    def all(self) -> list: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __contains__(self, obj: Any) -> bool: ...
    def __getitem__(self, key: int | slice) -> Any: ...

class RelationshipDefinition:
    module_name: Incomplete
    module_file: Incomplete
    manager: Incomplete
    definition: Incomplete
    def __init__(self, relation_type: str, cls_name: str, direction: int, manager: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...
    def lookup_node_class(self) -> None: ...
    def build_manager(self, source: StructuredNode, name: str) -> RelationshipManager: ...

class ZeroOrMore(RelationshipManager):
    description: str

class RelationshipTo(RelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...

class RelationshipFrom(RelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...

class Relationship(RelationshipDefinition):
    def __init__(self, cls_name: str, relation_type: str, cardinality: type[RelationshipManager] = ..., model: type[StructuredRel] | None = None) -> None: ...
