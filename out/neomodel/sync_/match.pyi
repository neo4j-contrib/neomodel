from dataclasses import dataclass
from re import Pattern
from neomodel.exceptions import MultipleNodesReturned as MultipleNodesReturned
from neomodel.match_q import Q as Q, QBase as QBase
from neomodel.properties import AliasProperty as AliasProperty, ArrayProperty as ArrayProperty, Property as Property
from neomodel.semantic_filters import FulltextFilter as FulltextFilter, VectorFilter as VectorFilter
from neomodel.sync_ import relationship_manager as relationship_manager
from neomodel.sync_.database import db as db
from neomodel.sync_.node import StructuredNode as StructuredNode
from neomodel.sync_.relationship import StructuredRel as StructuredRel
from neomodel.typing import Subquery as Subquery, Transformation as Transformation
from neomodel.util import RelationshipDirection as RelationshipDirection
from typing import Any, Iterator

CYPHER_ACTIONS_WITH_SIDE_EFFECT_EXPR: Pattern
OPERATOR_TABLE: dict[str, str]
path_split_regex: Pattern

def install_traversals(cls, node_set: NodeSet) -> None: ...
def process_filter_args(cls, kwargs: dict[str, Any]) -> dict: ...
def process_has_args(cls, kwargs: dict[str, Any]) -> tuple[dict, dict]: ...

class QueryAST:
    match: list[str]
    optional_match: list[str]
    where: list[str]
    with_clause: str | None
    return_clause: str | None
    order_by: list[str] | None
    skip: int | None
    limit: int | None
    result_class: type | None
    lookup: str | None
    additional_return: list[str] | None
    is_count: bool | None
    vector_index_query: VectorFilter | None
    fulltext_index_query: FulltextFilter | None
    optional_where: list[str] | None
    subgraph: dict
    mixed_filters: bool
    def __init__(self, match: list[str] | None = None, optional_match: list[str] | None = None, where: list[str] | None = None, optional_where: list[str] | None = None, with_clause: str | None = None, return_clause: str | None = None, order_by: list[str] | None = None, skip: int | None = None, limit: int | None = None, result_class: type | None = None, lookup: str | None = None, additional_return: list[str] | None = None, is_count: bool | None = False, vector_index_query: VectorFilter | None = None, fulltext_index_query: FulltextFilter | None = None) -> None: ...

class QueryBuilder:
    node_set: BaseSet
    def __init__(self, node_set: BaseSet, subquery_namespace: str | None = None) -> None: ...
    def build_ast(self) -> QueryBuilder: ...
    def build_source(self, source: Traversal | NodeSet | StructuredNode | Any) -> str: ...
    def create_relation_identifier(self) -> str: ...
    def create_node_identifier(self, prefix: str, path: str) -> str: ...
    def build_order_by(self, ident: str, source: NodeSet) -> None: ...
    def build_vector_query(self) -> None: ...
    def build_fulltext_query(self) -> None: ...
    def build_traversal(self, traversal: Traversal) -> str: ...
    def build_traversal_from_path(self, relation: Path, source_class: Any) -> tuple[str, Any]: ...
    def build_node(self, node: StructuredNode) -> str: ...
    def build_label(self, ident: str, cls: type[StructuredNode]) -> str: ...
    def build_additional_match(self, ident: str, node_set: NodeSet) -> None: ...
    def build_where_stmt(self, ident: str, filters: list, source_class: type[StructuredNode], q_filters: QBase | Any | None = None) -> None: ...
    def lookup_query_variable(self, path: str, return_relation: bool = False) -> tuple[str, Any, bool] | None: ...
    def build_query(self) -> str: ...

class BaseSet:
    query_cls = QueryBuilder
    source_class: type[StructuredNode]
    def all(self, lazy: bool = False) -> list: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __contains__(self, obj: StructuredNode | Any) -> bool: ...
    limit: int | None
    skip: int | None
    def __getitem__(self, key: int | slice) -> BaseSet | None: ...

@dataclass
class Optional:
    relation: str

@dataclass
class Path:
    value: str
    optional: bool = ...
    include_nodes_in_return: bool = ...
    include_rels_in_return: bool = ...
    relation_filtering: bool = ...
    alias: str | None = ...

@dataclass
class RelationNameResolver:
    relation: str
    def resolve(self, qbuilder: QueryBuilder) -> str: ...

@dataclass
class NodeNameResolver:
    node: str
    def resolve(self, qbuilder: QueryBuilder) -> str: ...

@dataclass
class BaseFunction:
    input_name: str | BaseFunction | NodeNameResolver | RelationNameResolver
    def __post_init__(self) -> None: ...
    def get_internal_name(self) -> str: ...
    def resolve_internal_name(self, qbuilder: QueryBuilder) -> str: ...
    def render(self, qbuilder: QueryBuilder) -> str: ...

@dataclass
class AggregatingFunction(BaseFunction): ...

@dataclass
class Collect(AggregatingFunction):
    distinct: bool = ...
    def render(self, qbuilder: QueryBuilder) -> str: ...

@dataclass
class ScalarFunction(BaseFunction):
    @property
    def function_name(self) -> str: ...
    def render(self, qbuilder: QueryBuilder) -> str: ...

@dataclass
class Last(ScalarFunction):
    @property
    def function_name(self) -> str: ...

@dataclass
class Size(ScalarFunction):
    @property
    def function_name(self) -> str: ...

@dataclass
class RawCypher:
    statement: str
    def __post_init__(self) -> None: ...
    def render(self, context: dict) -> str: ...

class NodeSet(BaseSet):
    source: Any
    source_class: Any
    filters: list
    q_filters: Q
    order_by_elements: list
    must_match: dict
    dont_match: dict
    relations_to_fetch: list[Path]
    vector_query: VectorFilter | None
    fulltext_query: FulltextFilter | None
    def __init__(self, source: Any) -> None: ...
    def __await__(self) -> Any: ...
    def get(self, lazy: bool = False, **kwargs: Any) -> Any: ...
    def get_or_none(self, **kwargs: Any) -> Any: ...
    def first(self, **kwargs: Any) -> Any: ...
    def first_or_none(self, **kwargs: Any) -> Any: ...
    def filter(self, *args: Any, **kwargs: Any) -> BaseSet: ...
    def exclude(self, *args: Any, **kwargs: Any) -> BaseSet: ...
    def has(self, **kwargs: Any) -> BaseSet: ...
    def order_by(self, *props: Any) -> BaseSet: ...
    def unique_variables(self, *paths: str) -> NodeSet: ...
    def traverse(self, *paths: tuple[str, ...], **aliased_paths: dict) -> NodeSet: ...
    def annotate(self, *vars: tuple, **aliased_vars: tuple) -> NodeSet: ...
    def resolve_subgraph(self) -> list: ...
    def subquery(self, nodeset: NodeSet, return_set: list[str], initial_context: list[str] | None = None) -> NodeSet: ...
    def intermediate_transform(self, vars: dict[str, Transformation], distinct: bool = False, ordering: list | None = None) -> NodeSet: ...

class Traversal(BaseSet):
    definition: dict
    source: Any
    source_class: Any
    target_class: Any
    name: str
    filters: list
    def __await__(self) -> Any: ...
    def __init__(self, source: Any, name: str, definition: dict) -> None: ...
    def match(self, **kwargs: Any) -> Traversal: ...
